#!/usr/bin/env lua
--[[
  Copyright (C) 2020 LibreMesh.org
  This is free software, licensed under the GNU AFFERO GENERAL PUBLIC LICENSE Version 3

  Copyright 2020 Santiago Piccinini <spiccinini@altermindi.net>
]]--

local ubus = require "ubus"
local json = require 'luci.jsonc'
local utils = require 'lime.utils'
local config = require 'lime.config'
local upgrade = require 'lime.upgrade'

local conn = ubus.connect()
if not conn then
    error("Failed to connect to ubus")
end

local UPGRADE_METADATA_FILE = "/etc/upgrade_metadata"


local function set_root_password(msg)
    local result = nil
    if type(msg.password) ~= "string" then
        result = {status = 'error', msg = 'Password must be a string'}
    else
        utils.set_shared_root_password(msg.password or '')
        result = {status = 'ok'}
    end
    return utils.printJson(result)
end

local function set_hostname(msg)
    if msg.hostname ~= nil and utils.is_valid_hostname(msg.hostname) then
        local uci = config.get_uci_cursor()
        uci:set(config.UCI_NODE_NAME, 'system', 'hostname', msg.hostname)
        uci:commit(config.UCI_NODE_NAME)
        utils.unsafe_shell("lime-config")
        return utils.printJson({ status = 'ok'})
    else
        local err
        if msg.hostname then
            err = 'Invalid hostname'
        else
            err = 'Hostname not provided'
        end
        return utils.printJson({ status = 'error', msg = err })
    end
end

local function is_upgrade_confirm_supported()
    local supported = upgrade.is_upgrade_confirm_supported()
    return utils.printJson({status = 'ok', supported = supported})
end


local function firmware_upgrade(msg)
    local status, ret = upgrade.firmware_upgrade(msg.fw_path, msg.preserve_config, msg.metadata, msg.fw_type)
    if status then
        return utils.printJson({status = 'ok', metadata = ret})
    else
        return utils.printJson({status = 'error', message = ret})
    end
end

local function last_upgrade_metadata()
    local metadata
    if utils.file_exists(UPGRADE_METADATA_FILE) then
        metadata = utils.read_obj_store(UPGRADE_METADATA_FILE)
        return utils.printJson({status = 'ok', metadata = metadata})
    else
        return utils.printJson({status = 'error', message = 'No metadata available'})
    end
end

local function firmware_confirm()
    local exit_code = os.execute("safe-upgrade confirm > /dev/null 2>&1")
    local status = 'error'
    if exit_code == 0 then
        status = 'ok'
    end
    return utils.printJson({status = status, exit_code = exit_code})
end


local methods = {
    set_root_password = { password = 'value'},
    set_hostname = { hostname = 'value'},
    is_upgrade_confirm_supported = { no_params = 0 },
    firmware_upgrade = { fw_path = 'value', preserve_config = 'value', metadata = 'value', fw_type = 'value'},
    last_upgrade_metadata = { no_params = 0 },
    firmware_confirm = { no_params = 0 }
}

if arg[1] == 'list' then
    utils.printJson(methods)
end

if arg[1] == 'call' then
    local msg = utils.rpcd_readline()
    msg = json.parse(msg)
    if      arg[2] == 'set_root_password' then set_root_password(msg)
    elseif  arg[2] == 'set_hostname' then set_hostname(msg)
    elseif  arg[2] == 'is_upgrade_confirm_supported' then is_upgrade_confirm_supported(msg)
    elseif  arg[2] == 'firmware_upgrade' then firmware_upgrade(msg)
    elseif  arg[2] == 'last_upgrade_metadata' then last_upgrade_metadata(msg)
    elseif  arg[2] == 'firmware_confirm' then firmware_confirm(msg)
    else utils.printJson({ error = "Method not found" })
    end
end
